The sixth week of the IBI course was mainly focused on the SIR model, which simulated and visualized the spread of infectious diseases in a population by writing and running three different Python programs. I think this is a very interesting and challenging practical activity.

The first file simulates the basic SIR model of disease transmission in a non spatial form. The logic of this part of the code is relatively simple and clear, which involves simulating the infection and recovery process through probability, gradually updating the numbers of the S, I, and R populations, and finally drawing a transmission trend chart. Although the idea is not complicated, I believe that for beginners like me, it is important to pay attention to the order of data updates, the syntax of probability simulation, and the use of functions such as np. random. choose().

The following is a version that adds the variable of vaccination rate to the basic SIR model, which makes me feel the strong scalability of the model. By constructing different vaccination rate scenarios, we can clearly see that the number of infected individuals decreases significantly with the increase of vaccination. Although the code structure is slightly more complex, it allows me to exercise my ability to adapt existing code. What impressed me the most was that even with only a 10% increase in vaccination rates, the changes in the curve were very noticeable. It presents the effect of herd immunity very intuitively, which coincides with the viewpoint in my IBMS paper on vaccines written at the end of last semester.

Finally, there is the simulation of the spatial SIR model. Compared to the previous two "one-dimensional time population" models, the spatial model introduces the concept of geographic location. Each individual exists as a state value on a 100x100 two-dimensional grid and only infects those around them. Although the double for loop in spatial propagation simulation is slightly cumbersome and has relatively low running efficiency, the image effect generated after code execution is very impressive. The images at different time points (such as t=10, t=50, t=100) show how the disease rapidly spreads from one point to the entire area, which is very intuitive.

Of course, as a beginner, I inevitably encountered some difficulties in the process, such as initially confusing the parameter meanings of np.random.choice and causing spatial model errors due to array out of bounds. However, through repeated checks and adjustments, I gradually mastered the skills of problem localization and solution, and gradually overcame my fear of programming.
